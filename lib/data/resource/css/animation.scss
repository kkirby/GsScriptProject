@import (css)(sys.animationTweens);

@function _tween($func,$start,$end,$time,$duration){
	$p: $time / $duration;
	@if $p >= 1 {
		@return $end;
	}
	$v: 0;
	@if $func == linear {
		$v: tweenLinear($p);
	}
	@elseif $func == easeIn {
		$v: tweenEaseIn($p);
	}
	@elseif $func == easeOut {
		$v: tweenEaseOut($p);
	}
	@elseif $func == easeInOut {
		$v: tweenEaseInOut($p);
	}
	@elseif $func == backIn {
		$v: tweenBackIn($p);
	}
	@elseif $func == backOut {
		$v: tweenBackOut($p);
	}
	@elseif $func == elastic {
		$v: tweenElastic($p);
	}
	@elseif $func == bounce {
		$v: tweenBounce($p);
	}
	
	@if type-of($start) == color {
		@return mix($end,$start,percentage(min($v,1)));
	}
	@else {
		$ret: max($start + ($end - $start) * $v,0);
		@if unitless($ret) {
			@return round($ret * 1000) / 1000;
		}
		@if unit($ret) == px {
			@return round($ret);
		}
		@else {
			@return round($ret * 100) / 100;
		}
	}
}

@mixin tween($name,$animations){
	@include keyframes($name){
		@for $i from 0 through 100 {
			$p: $i * 1%;
			#{$p} {
				$contentMap: ();
				@each $animationName, $animationConfig in $animations {
					$value: _tween(nth($animationConfig,3),nth($animationConfig,1),nth($animationConfig,2),$i,100);
					$contentMap: map-merge($contentMap,(#{$animationName}:#{$value}));
				}
				$_: StartContent($contentMap);
				@content;
				$_: EndContent();
			}
		}
	}
	@include animation($name linear 1s);
}